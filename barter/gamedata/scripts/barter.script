-- whenever talk to an NPC - create up to 3 barter items stored in global storage, when barter is made remove the item, wipe when entity is released
-- create barter based on community 
-- 0 is give (what npc gives), 1 is take (what npc takes)
local barters = {}
local barter_types = {"ammo","food","med","misc","loot"}
local barter_table = ini_file("settings\\barter.ltx")
local DEBUG = false

--TODO evaluate based on rep
local chance = DEBUG and 100 or 60
function print_dbg(txt, ...)
	if DEBUG then
		printf("barter | %s | " .. txt, time_global(), ...)
	end
end

local function bts(s)
    k,v = str_explode(s, ",")
    return v .. " " .. ui_item.get_sec_name(k)
end

local function build_barter_string(b)
    local num = #b
    if num == 1 then
        return str.format(game.translate_string("st_stalker_barter_dialog_reply_1"), bts(b[1][0]), bts(b[1][1]))
    elseif num == 2 then
        return str.format(game.translate_string("st_stalker_barter_dialog_reply_2"), bts(b[1][0]), bts(b[1][1]), bts(b[2][0]), bts(b[2][1]))
    elseif num == 3 then
        return str.format(game.translate_string("st_stalker_barter_dialog_reply_3"), bts(b[1][0]), bts(b[1][1]), bts(b[2][0]), bts(b[2][1]), bts(b[3][0]), bts(b[3][1]))
    else return nil end
end

-- create triple of ammo type and quantity
local ammo_table = { 
    "grenade_rgd5,1",
    "grenade_f1,1",
    "ammo_secondary,1",
    "ammo_primary,2" }

-- novices have only a single weapon, return first weapon found
local function is_primary_weapon(weapon, rank)
    return rank == "novice" or not IsPistol(nil,weapon:clsid())
end
local function is_secondary_weapon(weapon, rank)
    return rank == "novice" or IsPistol(nil,weapon:clsid())
end

local function is_appropriate_weapon(itm, npc_rank, ammo_type)
    return (ammo_type == "ammo_primary" and is_primary_weapon(itm, npc_rank)) or (ammo_type == "ammo_secondary" and is_secondary_weapon(itm, npc_rank))
end
local function create_ammo_barter(npc)
    local roll = math.random(5)
    if roll == 5 then roll = 4 end
	local npc_rank = ranks.get_obj_rank_name(npc)
    local sec, amt = nil
    if roll < 3 then sec, amt = str_explode(ammo_table[roll])
    else
        ammo_type,amt = str_explode(ammo_table[roll])
        local function itr(npc, item) 
            if (not sec and IsWeapon(nil,itm:clsid()) and not IsMelee(nil, itm:clsid()) and is_appropriate_weapon() and not npc:marked_dropped(itm)) then
                ammo_class = parse_list(ini_sys,itm:section(),"ammo_class")
                -- randomly spawn only 1 ammo type per found weapon
                if (#ammo_class > 0) then
                    sec = ammo_class[math.random(1,#ammo_class)]
                end
            end
        end
    	npc:iterate_inventory(itr,npc) 
    end
    return nil, sec, amt
end

-- Pick random section for give and take items, balanced by weight
local function random_section(npc, give, take)
    local give_num = math.random(barter_table:line_count(give))
    local take_num = math.random(barter_table:line_count(take))
    local _, give_sec, give_amt = give == "ammo" and create_ammo_barter(npc) or barter_table:r_line_ex(give, give_num)
    local _, take_sec, take_amt = take == "ammo" and create_ammo_barter(npc) or barter_table:r_line_ex(take, take_num)
    -- balance it out
    if (give_amt > take_amt) then
        take_amt = give_amt / take_amt
        give_amt = 1
    elseif (give_amt < take_amt) then
        give_amt = take_amt / give_amt
        take_amt = 1
    else
        give_amt = 1
        take_amt = 1
    end
    return {give_sec..","..give_amt, take_sec..","..take_amt}
end

-- create dialog with up to 3 swaps, create 3 options to accept the swaps
function start_barter(a, b)
    local npc = dialogs.who_is_npc(a, b)
    local id = npc:id()
    if barters[id] == false then
        return false
    elseif barters[id] then
        -- load barters
        return build_barter_string(barters[id])
    else
        barters[npc:id()] = {}
        -- not talked to yet, create barters
        for i = 1,3 do
            -- roll random number from 10 to 49, first digit is take index, second is give index
            -- stalkers can give you loot for supplies
            local barternum = math.random(10,50)
            local take = barter_types[math.floor(barternum/10)]
            local give_num = (barternum % 10) + 1
            if give_num > 5 then give_num = give_num - 5 end
            local give = barter_types[give_num]
            
            local community = npc:community()
            local a, b, give_section = barter_table:r_line_ex(community, give)
            local c, d, take_section = barter_table:r_line_ex(community, take)
            barters[id][i] = random_section(npc, give_section, take_section)
            return build_barter_string(barters[id])
        end
    end
end
local chance = DEBUG and 100 or 60
-- true if stalker accepts barter, and mark
function accept_barter(a, b)
    local npc = dialogs.who_is_npc(a, b)
    local community = alife_character_community(npc)
	if (npc_items == nil) then
		init_items = (math.random(100) <= chance) and true or false
    end
    if not init_items then barters[npc:id()] = false end
    return init_items
end

function decline_barter(a, b)
	local npc = who_is_npc(a, b)
    local id = npc:id()
    return barters[npc:id()] == false
end

local function accept(num)
    return str.format(game.translate_string("st_stalker_barter_dialog_accept"), bts(barters[num][0]), bts(barters[num][1]))
end

function accept_1(a, b)
    return accept(1)
end
function accept_2(a, b)
    return accept(2)
end
function accept_3(a, b)
    return accept(3)
end

-- modified from utils_item to count multiuse items with full use
function get_amount(npc, section)
    local amount = 0
    local is_multi = IsItem("multiuse",section)
    local max_uses = ini_sys:r_float_ex(section,"max_uses")
    
    local function itr(temp, obj)
        if (obj:section() == section) then
            if is_multi then
                if obj:get_remaining_uses() == max_uses then amount = amount + 1 end
            else
                amount = amount + 1
            end
        end
    end
    npc:iterate_inventory(itr, nil)
    
    return amount
end

local function can_trade(a, b, num)
    local npc = dialogs.who_is_npc(a, b)
    local id = npc:id()
    if not barters[id][num] then return false
    else
        item,quant = str_explode(barters[id][num][1], ",")
    	local actor_item = item and actor:object(item)
        -- check if player has those items in that quantity, assume full usage for multiuse items
        if (actor_item ~= nil) then 
            local cnt = get_amount(db.actor, section)
            if (cnt >= quant) then
                return true
            end
        end
        return false
    end
end

function can_trade_1(a, b)
    return can_trade(a, b, 1)
end
function can_trade_2(a, b)
    return can_trade(a, b, 2)
end
function can_trade_3(a, b)
    return can_trade(a, b, 3)
end

local function trade(a, b, num)
    local npc = dialogs.who_is_npc(a, b)
    local id = npc:id()
    local give, g_quant =  str_explode(barters[id][num][0], ",")
    local take, t_quant =  str_explode(barters[id][num][1], ",")

    -- remove take items
    local max_uses = ini_sys:r_float_ex(take,"max_uses")
    local is_multi = IsItem("multiuse",take)
    local trade_npc = get_speaker()
    local function itr(obj)
        if (obj:section() == take) then
            if t_quant == 0 then return false end
            if is_multi and obj:get_remaining_uses() < max_uses then return false end
            if trade_npc then db.actor:transfer_item(obj, trade_npc)
            else alife_release(obj) end
            t_quant = t_quant - 1
        end
    end
    db.actor:inventory_for_each(itr)

    -- spawn give items
    for i in 1,g_quant do alife_create_item(give, db.actor) end

    barters[id][num] = nil

    if #barters[id] == 0 then barters[id] = false 
    else
        if (num == 1) then
            if barters[id][3] then
                barters[id][1] = barters[id][3]
                barters[id][3] = nil
            elseif barters[id][2] then
                barters[id][1] = barters[id][2]
                barters[id][2] = nil
            end
        elseif (num == 2) then
            if barters[id][3] then
                barters[id][2] = barters[id][3]
                barters[id][3] = nil
            elseif barters[id][1] then
                barters[id][1] = barters[id][2]
                barters[id][2] = nil
            end
        end
    end
end

function trade_1(a, b)
    return trade(a, b, 1)
end
function trade_2(a, b)
    return trade(a, b, 2)
end
function trade_3(a, b)
    return trade(a, b, 3)
end

local function npc_on_death_callback(npc,who)
    if barters[npc:id()] then
        barters[npc:id()] = nil
    end
end